@startuml trace_library_usage_sequence
skinparam sequenceMessageAlign center
participant GenericTraceAPI
participant TraceJobAllocator
participant RingBuffer
participant FlexibleAllocator
participant ShmChunkList as "ShmDataChunkList& \n (shm_data)"  

GenericTraceAPI -> TraceJobAllocator: AllocateShmJob(meta_info,\n shm_data)
TraceJobAllocator -> RingBuffer: GetEmptyElement()
RingBuffer --> TraceJobAllocator: return rb_element
alt rb_element == error
    TraceJobAllocator --> GenericTraceAPI: return error 
else rb_element == valid element
    
    alt AraComMetaInfo is not provided
        TraceJobAllocator --> GenericTraceAPI: return error\n invalid meta_info
    else AraComMetaInfo is provided
        /' Allocate MetaInfo '/
        TraceJobAllocator -> FlexibleAllocator: Allocate(sizeof(meta_info))
        note over FlexibleAllocator
        This will allocate in TMD 
        area of size metainfo
        endnote
        FlexibleAllocator --> TraceJobAllocator: return meta_info_trace_format_ptr
        alt meta_info_trace_format_ptr == nullptr
            TraceJobAllocator --> GenericTraceAPI: return error\n kNotEnoughMemoryRecoverable
        else meta_info_trace_format_ptr is valid
            TraceJobAllocator -> TraceJobAllocator: Create AraComMetaInfoTraceFormat object\n at meta_info_trace_format_ptr address
            note over TraceJobAllocator
            We need the offset between 
            base address of TMD and meta_info_trace_format_ptr
            To append this data to ShmDataChunkList
            endnote
            TraceJobAllocator -> TraceJobAllocator: offset = GetOffset(meta_info_trace_format, trace_metadata_memory_resource_)
            alt offset == error
                TraceJobAllocator -> TraceJobAllocator: Update rb_element with status kInvalid
                TraceJobAllocator --> GenericTraceAPI: return error kNotEnoughMemoryRecoverable
            else offset == valid
                TraceJobAllocator -> TraceJobAllocator: chunk = SharedMemoryChunk\n{meta_info_trace_format_ptr, offset}
                TraceJobAllocator -> ShmChunkList: AppendFront(chunk)
                ShmChunkList --> TraceJobAllocator: return
            end
        end
    end

    |||

    /' Allocate Timestamp '/
    TraceJobAllocator -> FlexibleAllocator: timestamp_ptr = Allocate(sizeof(timestamp))
    note over FlexibleAllocator
    This will allocate in TMD 
    area of size timestamp
    endnote
    FlexibleAllocator --> TraceJobAllocator: return timestamp_ptr
    alt timestamp_ptr == nullptr
        TraceJobAllocator -> TraceJobAllocator: Update rb_element with status kInvalid
        TraceJobAllocator --> GenericTraceAPI: return error\n memory full
    else timestamp_ptr is valid
        alt HW Timer is initialized successfully
            TraceJobAllocator -> LoggerTime: Now()
            LoggerTime --> TraceJobAllocator: return plp_time
            TraceJobAllocator -> TraceJobAllocator: mw::time::hwloggertime::serialize2plp(plp_time_point) 
        else HW Timer is not initialized successfully
            TraceJobAllocator --> TraceJobAllocator: timestamp field is set with zeroes\n return 0
        end
        TraceJobAllocator -> TraceJobAllocator: Copy plp_time_point to timestamp_ptr
        note over TraceJobAllocator
        We need to the offset between 
        base address of TMD and timestamp_ptr
        To append this data to ShmChunkList
        endnote
        TraceJobAllocator -> TraceJobAllocator: offset = GetOffset(timestamp_ptr)
        alt offset == error
            TraceJobAllocator -> TraceJobAllocator: Update rb_element with status kInvalid
            TraceJobAllocator --> GenericTraceAPI: return error
        else offset == valid
            TraceJobAllocator -> TraceJobAllocator: chunk = SharedMemoryChunk\n{timestamp_ptr, offset}
            TraceJobAllocator -> ShmChunkList: AppendFront(chunk)
            ShmChunkList --> TraceJobAllocator: return
        end
    end

    TraceJobAllocator -> ShmChunkList: SaveToSharedMemory
    ShmChunkList -> ShmChunkList: Copies the chunk list itself \nas well as the meta_info and\n timestamp to the TMD area. 
    ShmChunkList --> TraceJobAllocator: return shm_location_in_tmd
    alt shm_location_in_tmd==error
        TraceJobAllocator -> TraceJobAllocator: Update rb_element with status kInvalid
        TraceJobAllocator --> GenericTraceAPI: return error
    else shm_location_in_tmd==valid
        TraceJobAllocator -> TraceJobAllocator: Update rb_element with \nshm_location_in_tmd and client info
        TraceJobAllocator -> TraceJobAllocator: Update rb_element to kReady
        TraceJobAllocator -> TraceJobContainer: Add rb_element, client info and shm_location_in_tmd to container
        TraceJobContainer --> TraceJobAllocator: return result
        alt result == error
            TraceJobAllocator -> TraceJobAllocator: Get pointer to the vector with chunk_list
            TraceJobAllocator -> TraceJobAllocator: Release vector memory
            TraceJobAllocator -> TraceJobAllocator: Update rb_element with status kInvalid
            TraceJobAllocator --> GenericTraceAPI: return error
        else result == success
            TraceJobAllocator -> GenericTraceAPI: return success
        end
    end
end

@enduml
