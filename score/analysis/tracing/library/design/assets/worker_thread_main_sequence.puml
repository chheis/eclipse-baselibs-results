@startuml background_sequence
activate WorkerThread
note over WorkerThread: state=kInitialized
loop no stop requested
    opt state==kDaemonDisconnected
        WorkerThread -> WorkerThread: global_error = kDaemonDisconnectedFatal
        WorkerThread -> WorkerThread: break
    end
    ' ProcessJobs function
    alt WorkerThread -> TraceJobProcessor: ProcessJobs() success
    activate TraceJobProcessor
    TraceJobProcessor->TraceJobProcessor: Check deallocator function is set
    TraceJobProcessor-> TraceJobContainer: GetReadyElement()
    activate TraceJobContainer
    TraceJobContainer-> TraceJobProcessor: return element
    deactivate TraceJobContainer

    loop no stop requested && element has value
        note over TraceJobProcessor
        To verify if a job has been completed
        the processor compares the stored GlobalContextId
        (TraceClientId+ContextId) of the job
        that was put in the queue with the GlobalContextId
        that is currently in occupying the same ring buffer
        element. If they are different it means the element
        was set to empty by the IPC tracing backend and
        was used to queue another trace job request.
        endnote

        alt element.original_trace.context_id != element.ring_buffer_element.context_id

            TraceJobProcessor -> TraceJobProcessor : call deallocate function
            note over TraceJobProcessor
            if the element refers to a zero-copy trace
            job the client defined callback also needs
            to be called
            endnote
            opt element.job_type == kShmJob
                note over TraceJobProcessor
                Callbacks are register using the local
                TraceClientID but jobs are filled using
                the remote TraceClientID.
                Therefore the worker thread needs to query
                the container.
                endnote
                TraceJobProcessor-> TraceClientContainer: GetLocalTraceClientId(element.context_id_.client_id_)
                activate TraceClientContainer
                TraceClientContainer -> TraceJobProcessor: return local_client_id
                deactivate TraceClientContainer
                opt local_client_id exists && has a registered callback
                    TraceJobProcessor -> TraceJobProcessor: call user-defined deallocate callback(element.original_trace.context_id)
                end
                loop return != true && no stop requested
                TraceJobProcessor -> TraceJobContainer: ReleaseReadyElement()
                activate TraceJobContainer
                note over TraceJobContainer
                This updates the state of the ring buffer
                and frees the element for acquisition
                endnote
                TraceJobContainer -> TraceJobProcessor: return
                deactivate TraceJobContainer
            end
            |||
        else
            TraceJobProcessor-> TraceJobProcessor: break
        end
        |||

        ' Get a new element
        TraceJobProcessor-> TraceJobContainer: GetReadyElement()
        activate TraceJobContainer
        TraceJobContainer-> TraceJobProcessor: return element
        deactivate TraceJobContainer
    end
    |||

    TraceJobProcessor --> WorkerThread: return
    else ProcessJobs() Failed
        WorkerThread-->WorkerThread : set global error with kFailedToProcessJobsFatal
    |||
    deactivate TraceJobProcessor
    opt return==error
        WorkerThread -> WorkerThread: break
    end
    WorkerThread -> WorkerThread: conccurent_sleep(kWorkerThreadPeriodicity)
end

@enduml
