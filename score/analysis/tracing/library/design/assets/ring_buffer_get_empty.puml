@startuml ring_buffer_get_empty_element
skinparam sequenceMessageAlign center

TraceJobAllocator-> ShmRingBuffer: GetEmptyElement()
alt ring buffer is not intialized
    ShmRingBuffer --> TraceJobAllocator : return error \n kRingBufferNotInitializedRecoverable
end
loop retries < kMaxGetElementRetries
    ShmRingBuffer -> ShmDataSegment: current_state = atomically load state
    alt !IsStateValid(current_state)
        ShmRingBuffer --> TraceJobAllocator: return error \n kRingBufferInvalidStateRecoverable
    end
    alt buffer is full
        ShmRingBuffer --> TraceJobAllocator: return error \n kRingBufferFullRecoverable
    end
    ShmRingBuffer -> ShmRingBuffer: previous_end_index = current_state.end
    ShmRingBuffer -> ShmRingBuffer: element = shm_data_->vector_[previous_end_index]
    alt element is not empty
        ShmRingBuffer --> ShmRingBuffer: continue with next retry
    end
    ShmRingBuffer -> ShmRingBuffer: new_end_index = (previous_end_index + 1U) % size_
    ShmRingBuffer -> ShmRingBuffer: Create new_state with new_end_index
    ShmRingBuffer -> ShmDataSegment: cas_result = compare_exchange_weak(current_state, new_state)
    alt !cas_result
        ShmRingBuffer -> ShmRingBuffer: continue with next retry
    end
    ShmRingBuffer -> ShmDataSegment: Atomically update status of acquired \n element to kAllocated
    ShmRingBuffer --> TraceJobAllocator: return element
end
ShmRingBuffer --> TraceJobAllocator: return error \n kRingBufferNoEmptyElementRecoverable
@enduml
