<diagram program="umletino" version="15.1"><zoom_level>12</zoom_level><help_text>Space for diagram notes</help_text><element><id>UMLClass</id><coordinates><x>180</x><y>492</y><w>348</w><h>84</h></coordinates><panel_attributes>/ITraceLibrary/
--
Interface of the implementation classes

fontsize=12
bg=white
fg=black</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>648</x><y>444</y><w>348</w><h>84</h></coordinates><panel_attributes>GenericTraceAPImpl
--
Actual implementation perfoms the needed logic 
Only one single static instance is created

fontsize=12
bg=white
fg=black</panel_attributes><additional_attributes></additional_attributes></element><element><id>Relation</id><coordinates><x>516</x><y>444</y><w>156</w><h>84</h></coordinates><panel_attributes>lt=&lt;&lt;-

fontsize=12
bg=white
fg=black</panel_attributes><additional_attributes>10;50;50;50;50;10;110;10</additional_attributes></element><element><id>UMLClass</id><coordinates><x>648</x><y>552</y><w>348</w><h>84</h></coordinates><panel_attributes>TraceLibraryMock
--
Mock to be used by the client in UT
Only exists in that scenario

fontsize=12
bg=white
fg=black</panel_attributes><additional_attributes></additional_attributes></element><element><id>Relation</id><coordinates><x>516</x><y>528</y><w>156</w><h>60</h></coordinates><panel_attributes>lt=&lt;&lt;-

fontsize=12
bg=white
fg=black</panel_attributes><additional_attributes>10;10;50;10;50;30;110;30</additional_attributes></element><element><id>Relation</id><coordinates><x>360</x><y>408</y><w>48</w><h>108</h></coordinates><panel_attributes>lt=&lt;&lt;&lt;&lt;-
m1=1
m2=1</panel_attributes><additional_attributes>10;10;10;70</additional_attributes></element><element><id>UMLClass</id><coordinates><x>180</x><y>0</y><w>1044</w><h>420</h></coordinates><panel_attributes>GenericTraceAPI 
--
Public tnterface exposed to the client
Implemented as a singleton, all methods are static
--
using TraceClientId = std::uint8_t
using TraceContextId = std::uint32_t
using TraceDoneCBType = score::cpp::callback&lt;void(TraceContextId)&gt;
--
+RegisterClient(const char* client_description) : score::result&lt;TraceClientId&gt;

+RegisterShmObject(const TraceClientId client, const char* shm_object_path) : score::result&lt;ShmObjectHandle&gt;
+RegisterShmObject(const TraceClientId client, int shm_object_fd) : score::result&lt;ShmObjectHandle&gt;

+UnregisterShmObject(const TraceClientId client, ShmObjectHandle) : score::result&lt;Blank&gt;

+RegisterTraceCallDoneCB(const TraceClientId client, TraceDoneCBType trace_done_cb) : score::result&lt;Blank&gt;

+Trace(const TraceClientId client, const MetaInfoVariants::type&amp; meta_info, ShmDataChunkList data, TraceContextId context_id) : score::result&lt;Blank&gt;
+Trace(const TraceClientId client, const MetaInfoVariants::type&amp; meta_info, LocalDataChunkList data) : score::result&lt;Blank&gt;
--

- static ITraceLibrary&amp; GetInstance() //returns either an Impl class or a mock depending on the scenario
- static void InjectMock(ITraceLibrary* mock) //Is called by the friend class TraceLibraryMock on construction to inject itself for the UTs. 


fontsize=12
bg=white
fg=black</panel_attributes><additional_attributes></additional_attributes></element></diagram>
