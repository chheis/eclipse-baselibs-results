@startuml ring_buffer_get_ready_element
skinparam sequenceMessageAlign center

TraceJobProcessor-> ShmRingBuffer: GetReadyElement()
alt ring buffer is not intialized
    ShmRingBuffer --> TraceJobProcessor : return error \n kRingBufferNotInitializedRecoverable
end
loop retries < kMaxGetElementRetries
    ShmRingBuffer -> ShmDataSegment: current_state = atomically load state
    alt !IsStateValid(current_state)
        ShmRingBuffer --> TraceJobProcessor: return error \n kRingBufferInvalidStateRecoverable
    end
    alt buffer is empty
        ShmRingBuffer --> TraceJobProcessor: return error \n kRingBufferEmptyRecoverable
    end
    ShmRingBuffer -> ShmRingBuffer: start_index = current_state.start
    ShmRingBuffer -> ShmDataSegment: element = vector_[(start_index)]
    ShmRingBuffer -> ShmRingBuffer: new_state = CreateNewState(current_state, start_index)
    alt IsElementReady(element)
        ShmRingBuffer -> ShmDataSegment: cas_result = compare_exchange_weak(current_state, new_state)
        alt !cas_result
            ShmRingBuffer -> ShmRingBuffer: continue with next retry
        end
        ShmRingBuffer --> TraceJobProcessor: return element
    else IsElementInvalid(element)
        ShmRingBuffer -> ShmDataSegment: cas_result = compare_exchange_weak(current_state, new_state)
        alt !cas_result
            ShmRingBuffer -> ShmRingBuffer: continue with next retry
        end
        ShmRingBuffer -> ShmDataSegment: Atomically update status of acquired \n element to kEmpty
    end
end
ShmRingBuffer --> TraceJobProcessor: return error \n kRingBufferNoReadyElementRecoverable
@enduml
