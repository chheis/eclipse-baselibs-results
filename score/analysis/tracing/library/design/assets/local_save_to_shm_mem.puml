@startuml trace_library_usage_sequence
skinparam sequenceMessageAlign center
participant TraceJobAllocator
participant LocalChunkList as "LocalDataChunkList&"  
participant FlexibleAllocator as "FlexibleAllocator&: \nallocator"
participant ShmChunkVector as "ShmChunkVector: \n vector"


TraceJobAllocator -> LocalChunkList: SaveToSharedMemory\n(mem_ressource \n shm_handle \n allocator)

alt mem_ressource is invalid OR shm_handle is invalid
    LocalChunkList-->TraceJobAllocator: return error kInvalidArgumentFatal
else
    LocalChunkList -> FlexibleAllocator: GetAvailableMemory()
    FlexibleAllocator --> LocalChunkList: return size_left

    LocalChunkList -> LocalChunkList: size_estimated \n = Estimate needed size based \n on alignement and STL size

    alt  size_left < size_estimated
        LocalChunkList-->TraceJobAllocator: return error kNotEnoughMemoryRecoverable
    else
        note over FlexibleAllocator
        The allocate method reserves 
        the necessary area
        in the TMD
        endnote
        LocalChunkList->FlexibleAllocator: vector_shm_raw_pointer = AllocateVector(flexible_allocator)
        FlexibleAllocator-->LocalChunkList: return result
        alt result == nullptr
            LocalChunkList --> TraceJobAllocator: return error kNotEnoughMemoryRecoverable
        else
            /' ConstructShmChunkVector '/
            LocalChunkList->ShmChunkVector: create ShmChunkVector at vector_shm_raw_pointer
            ShmChunkVector-->LocalChunkList: return vector
            /' FillVectorInSharedMemory '/
            note over LocalChunkList
            Now both control block and
            IPC data will be copied to TMD 
            endnote
            loop for all elements in the list
                alt element is valid (size!=0 & start!=nullptr)
                    LocalChunkList -> FlexibleAllocator: Allocate(element.size)
                    FlexibleAllocator --> LocalChunkList: return ptr
                    alt ptr is nullptr
                        note over LocalChunkList
                        This is the CleanupSequence()
                        endnote
                        loop for elements previously allocated
                            LocalChunkList -> FlexibleAllocator: Deallocate(pre_element)
                        end
                        LocalChunkList -> ShmChunkVector: clear()
                        LocalChunkList -> FlexibleAllocator: Deallocate(vector_shm_raw_pointer)
                        LocalChunkList --> TraceJobAllocator: return error not enought memory
                    else
                        LocalChunkList -> LocalChunkList: Add allocated element to tracking list
                        LocalChunkList -> LocalChunkList: Copy IPC data of element to ptr
                        LocalChunkList -> ShmChunkVector: push_back(\n ShmLocation{shm_handle, offset(ptr)} \n element.size)
                        ShmChunkVector --> LocalChunkList: return result
                        alt result is an error  
                            LocalChunkList -> LocalChunkList: CleanupSequence()
                            LocalChunkList --> TraceJobAllocator: return error kNotEnoughMemoryRecoverable
                        end
                    end
                end
            end
            LocalChunkList->LocalChunkList: vector_offset = GetOffsetFromPointer\n(vector, shm_handle)
            LocalChunkList --> TraceJobAllocator: return location of head of vector\n(shm_handle, vector_offset)
        end   
    end
end
@enduml
