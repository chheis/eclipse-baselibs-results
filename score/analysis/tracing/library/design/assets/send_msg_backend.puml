@startuml trace_library_usage_sequence
skinparam sequenceMessageAlign center


[-> DaemonCommunicator: MessageSend(request, response)

note over DaemonCommunicator
First the iov_t
structures for request 
and response need to
be prepared
endnote
DaemonCommunicator -> DaemonCommunicator: create iov_t request_msg
DaemonCommunicator -> Channel: SetIovConst\n(request_msg, \n&request, \nsizeof(request))

DaemonCommunicator -> DaemonCommunicator: create iov_t response_msg
DaemonCommunicator -> Channel: SetIovConst\n(request_msg, \n&response, \nsizeof(response))

note over DaemonCommunicator
Then a timer is set
to unblock the channel
if the backend does not answer
to unblock the thread. This
is needed as the library is FFI
endnote

DaemonCommunicator -> DaemonCommunicator: sigevent event\n with .sigev_notify = SIGEV_UNBLOCK \n is created
DaemonCommunicator -> Neutrino: Set TimerTimeout() for the thread \n states reply and send
Neutrino --> DaemonCommunicator: return result
alt result is succesfull
    DaemonCommunicator -> Channel: MsgSendv\n(channel_id, \n&request_msg, \n&response_msg)
    Channel --> DaemonCommunicator: return result
    alt result is succesfull
        DaemonCommunicator ->[: return success
    else 
        DaemonCommunicator ->[: return error msg send failed
    end
else result is an error
    DaemonCommunicator ->[: retunr error msg send failed
end






@enduml
