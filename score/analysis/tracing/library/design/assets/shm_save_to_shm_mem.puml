@startuml trace_library_usage_sequence
skinparam sequenceMessageAlign center
participant TraceJobAllocator
participant ShmDataChunkList as "ShmDataChunkList&"  
participant FlexibleAllocator as "FlexibleAllocator&: \nallocator"
participant ShmChunkVector as "ShmChunkVector&: \n vector"


TraceJobAllocator -> ShmDataChunkList: SaveToSharedMemory\n(mem_ressource \n shm_handle \n allocator)

alt mem_ressource is invalid OR shm_handle is invalid
    ShmDataChunkList-->TraceJobAllocator: return error kInvalidArgumentFatal
else
    ShmDataChunkList -> FlexibleAllocator: GetAvailableMemory()
    FlexibleAllocator --> ShmDataChunkList: return size_left

    ShmDataChunkList -> ShmDataChunkList: size_estimated \n = Estimate needed size based \n on alignement and STL size

    alt  size_left < size_estimated
        ShmDataChunkList-->TraceJobAllocator: return error kNotEnoughMemoryRecoverable
    else
        note over FlexibleAllocator
        The allocate method reserves 
        the necessary area for
        the head of the list
        in the TMD
        endnote
        ShmDataChunkList->FlexibleAllocator: vector_shm_raw_pointer = Allocate(\nsizeof(ShmChunkVector), \n16bit alignment)
        FlexibleAllocator-->ShmDataChunkList: return result
        alt result == error
            ShmDataChunkList --> TraceJobAllocator: return error kNotEnoughMemoryRecoverable
        else
            ShmDataChunkList->ShmChunkVector: create ShmChunkVector at vector_shm_raw_pointer
            ShmChunkVector--> ShmDataChunkList: return vector
        end
        ShmDataChunkList->ShmDataChunkList: offset = GetOffsetFromPointer\n(vector, mem_resource)
        ShmDataChunkList -> ShmDataChunkList: shm_location = SharedMemoryLocation for head of list\n (tmd_handle, offset)

        loop for all elements of the passed list
            ShmDataChunkList -> ShmChunkVector: emplace_back(element)
            note over ShmChunkVector
            ShmChunkVector performs its 
            own allocation algorithm in TMD
            endnote
            ShmChunkVector --> ShmDataChunkList: return result
            alt result is not succesfull
                ShmDataChunkList -> ShmChunkVector: clear()
                note over ShmChunkVector
                ShmChunkVector performs its 
                own deallocation algorithm for all nodes
                endnote
                ShmDataChunkList -> FlexibleAllocator: Deallocate(raw_vector_ptr)
                ShmDataChunkList -> TraceJobAllocator: return error kNotEnoughMemoryRecoverable
            end
            ShmDataChunkList -> TraceJobAllocator: return result
        end
    end
end


@enduml
